#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Define classes for geographic names, geographic strings, and associated utilities.

Classes
-------

Dict2StringlikeParser()
    Create a GeographicName or GeographicString from a dictionary.

GeographicName(CitedString)
    Record and manage information about a geographic name.

GeographicString(CitedString)
    Record and manage information about a geographically descriptive string.

"""

from collections.abc import Sequence, Set
import logging
from oikoumene.base import Base
from oikoumene.id import make_id_valid
from oikoumene.normalization import norm
from oikoumene.serialization import Serializeable
from pprint import pformat
from slugify import slugify
from typing import List, Union

logger = logging.getLogger(__name__)

class _CitedString(Base, Serializeable):
    """
    Represent data and behaviors common to both GeographicName and GeographicString classes.

    See oikoumene.base and oikoumene.serialization for definitions of the superclasses.
    
    Attributes
    ----------

    attested : str
        Form of string found in contemporary witnesses using unicode characters from the native
        language and script of those witnesses.

    romanized : list
        Each item in list is a unique string that constitutes a "romanization" of the "attested"
        form, i.e., its representation in unicode Latin characters according to some standard or
        ad hoc convention.

    NB: __init__() can set arbitrarily-named instance attributes if so instructed.

    """

    def __init__(
        self,
        attested: str='',
        romanized: Union[Sequence[str], Set[str]]=[],
        cleanup: bool=True,
        **kwargs
    ):
        """
        Instantiate an object whose class inherits from _CitedString
        
        Arguments:

        attested: str (default='')
            Specify initial value for the "attested" attribute (q.v.)

        romanized: list, tuple, or set of str (default=[])
            Specify initial value(s) for the "romanized" attribute (q.v.)

        cleanup: bool (default=True)
            Ensure that all string values assigned to attributes of this object are Unicode-normalized and 
            white-space normalized, to include stripping of any leading or trailing space.

        kwargs:
            key:value pairs assigned as ad hoc attributes on the object. NB: ad hoc attributes are not 
            subject to normalization on the basis of the "cleanup" argument.
            
        
        """
        Base.__init__(self)
        Serializeable.__init__(self)
        self._cleanup = cleanup
        self.attested = attested
        if not romanized and not attested:
            raise ValueError(
                f'At least one romanized or attested name form must be provided to initialize a Name.')
        elif not romanized:
            self.romanized = slugify(attested, lowercase=False, separator=' ')
        else:
            self.romanized = romanized
        for kw, arg in kwargs.items():
            setattr(self, kw, arg)

    @property
    def attested(self) -> str:
        """
        Get and set a Unicode string as found in contemporary witnesses. 
        
        assignment: str

        returns: str

        "attested" contains Unicode characters only from the appropriate code page(s) for the script
        of the original witnesses. Unless cleanup=False was passed to __init__() when the object was
        instantiated, any string assigned to this property will undergo Unicode normalization and
        whitespace normalization, to include stripping of any leading or trailing whitespace. Each 
        time a new value is assigned to this attribute, the value for the "id" attribute is
        regenerated by calling the private _generate_id() function.
        """
        try:
            return self._attested
        except AttributeError:
            return ''

    @attested.setter
    def attested(self, value: str):
        if self._cleanup:
            val = norm(value)
            if val == '':
                return
        else:
            val = value
        try:
            prior_val = self._attested
        except AttributeError:
            prior_val = ''
        if val != prior_val:
            self._attested = val
            self._generate_id()

    # romanized form(s) of the attested string
    @property
    def romanized(self) -> List[str]:
        """
        Get and set one or more Unicode strings recording unique romanizations of the attested form.
        
        assignment: str, list of str, tuple of str, set of str

        returns: list of str

        Each string in this list contains characters only from the Latin and Latin-Extended Unicode
        code pages. Each string represents a "romanized form" (i.e., transliteration into Latin
        characters) of the "attested" form. Each string subsequently assigned to this attribute 
        is appended to the list and the list is re-sorted alphabetically. Unless cleanup=False 
        was passed to __init__() when the object was instantiated, any string assigned to this 
        property will undergo Unicode normalization and whitespace normalization, to include 
        stripping of any leading or trailing whitespace. Each time a new value is assigned to this
        attribute, the value for the "id" attribute is regenerated by calling the private 
        _generate_id() function.
        """
        return self._romanized

    @romanized.setter
    def romanized(self, values:Union[str, Sequence[str], Set[str]]):
        expected = (str, Sequence, Set)
        if not isinstance(values, expected):
            expected = ', '.join([str(e) for e in expected])
            raise TypeError(
                f'Invalid type used to set Name.romanized. '
                f'Expected {expected} but got {type(values)}.')
        if isinstance(values, str):
            values = [values]
        dirty = False
        for v in values:
            if not isinstance(v, str):
                raise TypeError(
                    f'Invalid type used to set Name.romanized. '
                    f'Expected {str} but got {type(v)} ({v}).')
            if self._cleanup:
                val = norm(v)
                if val == '':
                    continue
            else:
                val = v
            try:
                self._romanized
            except AttributeError:
                self._romanized = []
            name_set = set(self._romanized)
            name_set.add(val)
            name_set = sorted(list(name_set))
            if name_set != self._romanized:
                self._romanized = name_set
                dirty = True
        if dirty:
            self._generate_id()

    def _generate_id(self):
        """
        Make the most useful possible identifier for this object.
        
        If present, the attested form is used as the basis of the id; otherwise, the alphabetically 
        first romanized form is used. The default output of the python-slugify package is used to
        produce a regularized and simplified version of the basis string, which is then assigned to
        the "id" attribute. Note that any regularization or validation applied to the "id" value by
        its setter property may further alter the result.
        """
        base = self.attested
        if not base:
            base = self.romanized[0]
        slug = slugify(base)
        if slug != self.id:
            try:
                self.prior_ids
            except AttributeError:
                self.prior_ids = set()
            self.prior_ids.add(self.id)
            self.id = slug

class GeographicName(_CitedString):
    """
    Represent data and behaviors associated with a geographic name.

    By "geographic name", we mean toponym, place name, region/area name, and the like. If a modern,
    English-speaking cartographer would title-capitalize the name on a map or in a gazetteer, then
    it is probably a "geographic name". Otherwise, see GeographicString.
    """

    def __init__(
        self,
        attested: str='',
        romanized: Union[Sequence[str], Set[str]]=[],
        cleanup: bool=True,
        **kwargs
    ):
        """
        Instantiate a GeographicName object.

        Arguments
        ---------

        attested: str (default='')
            Specify initial value for the "attested" attribute, which is inherited from _CitedString (q.v.)

        romanized: list, tuple, or set of str (default=[])
            Specify initial value(s) for the "romanized" attribute, which is inherited from _CitedString (q.v.)

        cleanup: bool (default=True)
            Ensure that all string values assigned to attributes of this object are Unicode-normalized and 
            white-space normalized, to include stripping of any leading or trailing space.

        kwargs:
            key:value pairs to be passed to the _CitedString __init__() method for addition as ad hoc attributes
            on the object.
        """

        _CitedString.__init__(self, attested, romanized, cleanup, **kwargs)


class GeographicString(_CitedString):
    """
    Represent data and behaviors associated with a geographic string.

    By "geographic string", we mean any word, phrase, or other sequence of words that corresponds to,
    mentions, evokes, or describes a place, region, area, or other geographic or spatial feature, but
    that does not constitute a "geographic name" in the cultural, scholarly, or analytic context.
    """

    def __init__(
        self,
        attested: str='',
        romanized: Union[Sequence[str], Set[str]]=[],
        cleanup: bool=True,
        **kwargs
    ):
        """
        Instantiate a GeographicString object.

        Arguments
        ---------

        attested: str (default='')
            Specify initial value for the "attested" attribute, which is inherited from _CitedString (q.v.)

        romanized: list, tuple, or set of str (default=[])
            Specify initial value(s) for the "romanized" attribute, which is inherited from _CitedString (q.v.)

        cleanup: bool (default=True)
            Ensure that all string values assigned to attributes of this object are Unicode-normalized and 
            white-space normalized, to include stripping of any leading or trailing space.

        kwargs:
            key:value pairs to be passed to the _CitedString __init__() method for addition as ad hoc attributes
            on the object.
        """    
        _CitedString.__init__(self, attested, romanized, cleanup, **kwargs)

        
class Dict2StringlikeParser:
    """
    Convert a dictionary to a GeographicName or GeographicString
    
    Methods
    -------

    parse_dict()
        Perform dictionary conversion.

    """

    def __init__(self):
        pass

    def parse_dict(self, source: dict, object_type: str='') -> Union[GeographicName, GeographicString]:
        """
        Perform dictionary conversion.
        
        Arguments
        ---------

        source: dict
            A python dictionary in which each key-value pair corresponds to desired attribute names and
            associated values. Specifically supported values include "attested" and "romanized", and at least
            one non-zero-length value must be provided for one of these two keys. Note, however, that all 
            key-value pairs are passed on to __init__() method of the output class. The special key
            "object_type" may be included in the dictionary to indicate the desired class of the resulting
            object. If "object_type" is omitted from the dictionary, or if its value is a zero-length,
            the parser will default to creating a GeographicString. See also the "object_type" keyword
            argument to this function, which may be used to override this behavior.

        object_type: str (default: '')
            A string containing the classname of the desired parser output object. If not a zero-length
            string, this argument overrides any object_type selection in the "source" dict.

        """
        if not isinstance(source, dict):
            raise TypeError(
                f'Unexpected type ({type(source)}) passed as "source" argument to "parse_dict" method. '
                f'Expected {dict}.')
        expected = ['GeographicName', 'GeographicString']
        if not isinstance(object_type, str):
            raise TypeError(
                f'Unexpected type ({type(object_type)}) passed as "object_type" argument to parse_dict method. '
                f'Expected {str}.')
        if object_type == '':
            try:
                object_type = source['object_type']
            except KeyError:
                object_type = 'GeographicString'
        if object_type not in expected:
            expected = ', '.join(expected)
            raise ValueError(
                f'Unsupported value for "object_type" ({object_type}). '
                f'Expected: {expected}.')
        return globals()[object_type](**{k: v for k, v in source.items() if k != 'object_type'})

